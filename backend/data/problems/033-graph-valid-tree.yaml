title: Graph Valid Tree
sequence_number: 33
difficulty: medium
pattern:
  - graph
  - union-find
  - dfs
  - bfs

description: |
  You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer `n` and a list of `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the graph.

  Return `true` if the edges of the given graph make up a valid tree, and `false` otherwise.

  A valid tree has exactly `n - 1` edges, is connected, and has no cycles.

constraints:
  - "1 <= n <= 2000"
  - "0 <= edges.length <= 5000"
  - "edges[i].length == 2"
  - "0 <= ai, bi < n"
  - "ai != bi"
  - "There are no self-loops or repeated edges."

examples:
  - input: "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]"
    output: "true"
  - input: "n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]"
    output: "false"

languages:
  python:
    starter_code: |
      class Solution:
          def validTree(self, n: int, edges: List[List[int]]) -> bool:
              pass
    reference_solution: |
      class Solution:
          def validTree(self, n: int, edges: List[List[int]]) -> bool:
              # A tree must have exactly n-1 edges
              if len(edges) != n - 1:
                  return False

              # Build adjacency list
              graph = [[] for _ in range(n)]
              for a, b in edges:
                  graph[a].append(b)
                  graph[b].append(a)

              # BFS to check if graph is connected
              visited = set([0])
              queue = [0]

              while queue:
                  node = queue.pop(0)
                  for neighbor in graph[node]:
                      if neighbor not in visited:
                          visited.add(neighbor)
                          queue.append(neighbor)

              # All nodes must be visited for connected graph
              return len(visited) == n
    function_signature:
      name: validTree
      params:
        - name: n
          type: int
        - name: edges
          type: "List[List[int]]"
      return_type: bool

test_cases:
  - input: [5, [[0, 1], [0, 2], [0, 3], [1, 4]]]
    expected: true
  - input: [5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]]
    expected: false
  - input: [1, []]
    expected: true
  - input: [2, [[0, 1]]]
    expected: true
  - input: [2, []]
    expected: false
  - input: [3, [[0, 1], [1, 2]]]
    expected: true
  - input: [3, [[0, 1], [1, 2], [0, 2]]]
    expected: false
  - input: [4, [[0, 1], [2, 3]]]
    expected: false
  - input: [4, [[0, 1], [0, 2], [0, 3]]]
    expected: true
  - input: [4, [[0, 1], [1, 2], [2, 3]]]
    expected: true
  - input: [5, [[0, 1], [0, 2], [0, 3], [0, 4]]]
    expected: true
  - input: [5, [[0, 1], [1, 2], [2, 3], [3, 4]]]
    expected: true
  - input: [5, [[0, 1], [0, 2], [1, 2], [3, 4]]]
    expected: false
  - input: [6, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]]]
    expected: true
  - input: [6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]]]
    expected: false
  - input: [4, [[0, 1], [1, 2], [2, 3], [3, 0]]]
    expected: false
  - input: [3, [[0, 1]]]
    expected: false
  - input: [7, [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5], [2, 6]]]
    expected: true
  - input: [8, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]]]
    expected: true
  - input: [4, [[0, 1], [0, 2], [0, 3], [1, 2]]]
    expected: false
