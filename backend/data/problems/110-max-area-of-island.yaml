title: Max Area of Island
sequence_number: 110
difficulty: medium
pattern:
  - graph
  - depth-first-search
  - breadth-first-search
  - matrix

description: |
  You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

  The **area** of an island is the number of cells with a value `1` in the island.

  Return the maximum area of an island in `grid`. If there is no island, return `0`.

constraints:
  - "m == grid.length"
  - "n == grid[i].length"
  - "1 <= m, n <= 50"
  - "grid[i][j] is either 0 or 1."

examples:
  - input: "grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]"
    output: "6"
  - input: "grid = [[0,0,0,0,0,0,0,0]]"
    output: "0"

languages:
  python:
    starter_code: |
      class Solution:
          def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
              pass
    reference_solution: |
      class Solution:
          def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
              if not grid:
                  return 0

              m, n = len(grid), len(grid[0])
              max_area = 0

              def dfs(i, j):
                  if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:
                      return 0
                  grid[i][j] = 0  # Mark as visited
                  return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)

              for i in range(m):
                  for j in range(n):
                      if grid[i][j] == 1:
                          max_area = max(max_area, dfs(i, j))

              return max_area
    function_signature:
      name: maxAreaOfIsland
      params:
        - name: grid
          type: "List[List[int]]"
      return_type: int

test_cases:
  - input: [[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]]
    expected: 6
  - input: [[[0,0,0,0,0,0,0,0]]]
    expected: 0
  - input: [[[1]]]
    expected: 1
  - input: [[[0]]]
    expected: 0
  - input: [[[1,1],[1,1]]]
    expected: 4
  - input: [[[1,0],[0,1]]]
    expected: 1
  - input: [[[1,1,1],[1,1,1],[1,1,1]]]
    expected: 9
  - input: [[[0,0,0],[0,1,0],[0,0,0]]]
    expected: 1
  - input: [[[1,0,1],[0,0,0],[1,0,1]]]
    expected: 1
  - input: [[[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]]
    expected: 4
  - input: [[[1,1,1,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]]
    expected: 5
  - input: [[[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[1,0,0,0,1]]]
    expected: 1
  - input: [[[1,1,0,1,1],[1,0,0,0,1],[0,0,1,0,0],[1,0,0,0,1],[1,1,0,1,1]]]
    expected: 3
  - input: [[[0,0,0,0],[0,0,0,0],[0,0,0,0]]]
    expected: 0
  - input: [[[1,1,1,1,1]]]
    expected: 5
