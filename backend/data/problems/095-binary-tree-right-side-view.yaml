title: Binary Tree Right Side View
sequence_number: 95
difficulty: medium
pattern:
  - trees
  - breadth-first-search
  - depth-first-search

description: |
  Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.

  The tree is represented as a level-order array where `null` represents missing nodes.

constraints:
  - "The number of nodes in the tree is in the range [0, 100]."
  - "-100 <= Node.val <= 100"

examples:
  - input: "root = [1,2,3,null,5,null,4]"
    output: "[1,3,4]"
  - input: "root = [1,null,3]"
    output: "[1,3]"
  - input: "root = []"
    output: "[]"

languages:
  python:
    starter_code: |
      class Solution:
          def rightSideView(self, root: List) -> List[int]:
              pass
    reference_solution: |
      class Solution:
          def rightSideView(self, root: List) -> List[int]:
              if not root:
                  return []

              # Build tree from array
              class TreeNode:
                  def __init__(self, val=0, left=None, right=None):
                      self.val = val
                      self.left = left
                      self.right = right

              def build_tree(arr):
                  if not arr or arr[0] is None:
                      return None
                  root = TreeNode(arr[0])
                  queue = [root]
                  i = 1
                  while queue and i < len(arr):
                      node = queue.pop(0)
                      if i < len(arr) and arr[i] is not None:
                          node.left = TreeNode(arr[i])
                          queue.append(node.left)
                      i += 1
                      if i < len(arr) and arr[i] is not None:
                          node.right = TreeNode(arr[i])
                          queue.append(node.right)
                      i += 1
                  return root

              tree_root = build_tree(root)
              result = []
              queue = [tree_root]

              while queue:
                  level_size = len(queue)
                  for i in range(level_size):
                      node = queue.pop(0)
                      if i == level_size - 1:
                          result.append(node.val)
                      if node.left:
                          queue.append(node.left)
                      if node.right:
                          queue.append(node.right)

              return result
    function_signature:
      name: rightSideView
      params:
        - name: root
          type: List
      return_type: "List[int]"

test_cases:
  - input: [[1, 2, 3, null, 5, null, 4]]
    expected: [1, 3, 4]
  - input: [[1, null, 3]]
    expected: [1, 3]
  - input: [[]]
    expected: []
  - input: [[1]]
    expected: [1]
  - input: [[1, 2]]
    expected: [1, 2]
  - input: [[1, 2, 3]]
    expected: [1, 3]
  - input: [[1, 2, 3, 4]]
    expected: [1, 3, 4]
  - input: [[1, 2, 3, 4, 5, 6, 7]]
    expected: [1, 3, 7]
  - input: [[1, 2, null, 3]]
    expected: [1, 2, 3]
  - input: [[1, 2, 3, null, 5, null, 4, 6]]
    expected: [1, 3, 4, 6]
  - input: [[1, 2, 3, 4, null, null, 5]]
    expected: [1, 3, 5]
  - input: [[3, 9, 20, null, null, 15, 7]]
    expected: [3, 20, 7]
  - input: [[1, 2, 3, 4, 5]]
    expected: [1, 3, 5]
  - input: [[1, null, 2, null, 3, null, 4]]
    expected: [1, 2, 3, 4]
  - input: [[1, 2, null, 3, null, 4, null, 5]]
    expected: [1, 2, 3, 4, 5]
