title: Diameter of Binary Tree
sequence_number: 93
difficulty: easy
pattern:
  - trees
  - depth-first-search
  - recursion

description: |
  Given the `root` of a binary tree, return the length of the **diameter** of the tree.

  The **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.

  The **length** of a path between two nodes is represented by the number of edges between them.

  The tree is represented as a level-order array where `null` represents missing nodes.

constraints:
  - "The number of nodes in the tree is in the range [1, 10^4]."
  - "-100 <= Node.val <= 100"

examples:
  - input: "root = [1,2,3,4,5]"
    output: "3"
    explanation: "The longest path goes through nodes [4,2,1,3] or [5,2,1,3], which has 3 edges."
  - input: "root = [1,2]"
    output: "1"

languages:
  python:
    starter_code: |
      class Solution:
          def diameterOfBinaryTree(self, root: List) -> int:
              pass
    reference_solution: |
      class Solution:
          def diameterOfBinaryTree(self, root: List) -> int:
              if not root:
                  return 0

              # Build tree from array
              class TreeNode:
                  def __init__(self, val=0, left=None, right=None):
                      self.val = val
                      self.left = left
                      self.right = right

              def build_tree(arr):
                  if not arr or arr[0] is None:
                      return None
                  root = TreeNode(arr[0])
                  queue = [root]
                  i = 1
                  while queue and i < len(arr):
                      node = queue.pop(0)
                      if i < len(arr) and arr[i] is not None:
                          node.left = TreeNode(arr[i])
                          queue.append(node.left)
                      i += 1
                      if i < len(arr) and arr[i] is not None:
                          node.right = TreeNode(arr[i])
                          queue.append(node.right)
                      i += 1
                  return root

              tree_root = build_tree(root)
              self.diameter = 0

              def height(node):
                  if not node:
                      return 0
                  left_h = height(node.left)
                  right_h = height(node.right)
                  self.diameter = max(self.diameter, left_h + right_h)
                  return 1 + max(left_h, right_h)

              height(tree_root)
              return self.diameter
    function_signature:
      name: diameterOfBinaryTree
      params:
        - name: root
          type: List
      return_type: int

test_cases:
  - input: [[1, 2, 3, 4, 5]]
    expected: 3
  - input: [[1, 2]]
    expected: 1
  - input: [[1]]
    expected: 0
  - input: [[1, 2, 3]]
    expected: 2
  - input: [[1, null, 2]]
    expected: 1
  - input: [[1, 2, null]]
    expected: 1
  - input: [[1, 2, 3, 4, 5, 6, 7]]
    expected: 4
  - input: [[1, 2, 3, 4, null, null, null, 5]]
    expected: 4
  - input: [[1, 2, null, 3, null, 4, null, 5]]
    expected: 4
  - input: [[1, 2, 3, null, 4, null, 5]]
    expected: 4
  - input: [[1, 2, 3, 4, 5, 6, 7, 8, 9]]
    expected: 5
  - input: [[5, 1, null, null, 4, 3, null, 2]]
    expected: 4
  - input: [[1, null, 2, null, 3]]
    expected: 2
  - input: [[1, 2, 3, 4, 5, null, null, 6, 7]]
    expected: 4
  - input: [[1, 2, null, 3, 4, 5]]
    expected: 3
