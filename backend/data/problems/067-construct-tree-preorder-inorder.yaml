title: Construct Binary Tree from Preorder and Inorder Traversal
sequence_number: 67
difficulty: medium
pattern:
  - tree
  - divide-and-conquer
  - recursion

description: |
  Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return the binary tree.

  Return the tree as an array in level-order (BFS), where `null` represents missing nodes.

constraints:
  - "1 <= preorder.length <= 3000"
  - "inorder.length == preorder.length"
  - "-3000 <= preorder[i], inorder[i] <= 3000"
  - "preorder and inorder consist of unique values."
  - "Each value of inorder also appears in preorder."
  - "preorder is guaranteed to be the preorder traversal of the tree."
  - "inorder is guaranteed to be the inorder traversal of the tree."

examples:
  - input: "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]"
    output: "[3,9,20,null,null,15,7]"
  - input: "preorder = [-1], inorder = [-1]"
    output: "[-1]"

languages:
  python:
    starter_code: |
      class Solution:
          def buildTree(self, preorder: List[int], inorder: List[int]) -> List:
              pass
    reference_solution: |
      class Solution:
          def buildTree(self, preorder: List[int], inorder: List[int]) -> List:
              from collections import deque

              class TreeNode:
                  def __init__(self, val=0):
                      self.val = val
                      self.left = None
                      self.right = None

              if not preorder or not inorder:
                  return []

              inorder_map = {val: idx for idx, val in enumerate(inorder)}
              pre_idx = [0]

              def build(left, right):
                  if left > right:
                      return None

                  root_val = preorder[pre_idx[0]]
                  pre_idx[0] += 1
                  root = TreeNode(root_val)

                  mid = inorder_map[root_val]
                  root.left = build(left, mid - 1)
                  root.right = build(mid + 1, right)

                  return root

              root = build(0, len(inorder) - 1)

              # Convert to array
              def tree_to_array(node):
                  if not node:
                      return []
                  result = []
                  queue = deque([node])
                  while queue:
                      curr = queue.popleft()
                      if curr:
                          result.append(curr.val)
                          queue.append(curr.left)
                          queue.append(curr.right)
                      else:
                          result.append(None)
                  while result and result[-1] is None:
                      result.pop()
                  return result

              return tree_to_array(root)
    function_signature:
      name: buildTree
      params:
        - name: preorder
          type: "List[int]"
        - name: inorder
          type: "List[int]"
      return_type: List

test_cases:
  - input: [[3, 9, 20, 15, 7], [9, 3, 15, 20, 7]]
    expected: [3, 9, 20, null, null, 15, 7]
  - input: [[-1], [-1]]
    expected: [-1]
  - input: [[1, 2], [2, 1]]
    expected: [1, 2]
  - input: [[1, 2], [1, 2]]
    expected: [1, null, 2]
  - input: [[1, 2, 3], [2, 1, 3]]
    expected: [1, 2, 3]
  - input: [[3, 2, 1], [1, 2, 3]]
    expected: [3, 2, null, 1]
  - input: [[1, 2, 4, 5, 3, 6, 7], [4, 2, 5, 1, 6, 3, 7]]
    expected: [1, 2, 3, 4, 5, 6, 7]
  - input: [[1, 2, 3], [1, 2, 3]]
    expected: [1, null, 2, null, 3]
  - input: [[3, 2, 1], [3, 2, 1]]
    expected: [3, null, 2, null, 1]
  - input: [[1], [1]]
    expected: [1]
  - input: [[5, 3, 2, 4, 7, 6, 8], [2, 3, 4, 5, 6, 7, 8]]
    expected: [5, 3, 7, 2, 4, 6, 8]
  - input: [[1, 2, 4, 3], [4, 2, 1, 3]]
    expected: [1, 2, 3, 4]
  - input: [[0], [0]]
    expected: [0]
  - input: [[-10, -20, -30], [-30, -20, -10]]
    expected: [-10, -20, null, -30]
  - input: [[4, 2, 1, 3, 6, 5, 7], [1, 2, 3, 4, 5, 6, 7]]
    expected: [4, 2, 6, 1, 3, 5, 7]
