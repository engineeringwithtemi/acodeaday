title: Serialize and Deserialize Binary Tree
sequence_number: 65
difficulty: hard
pattern:
  - tree
  - bfs
  - dfs
  - design

description: |
  Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

  Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

  For this problem, we verify that serialize followed by deserialize returns the original tree.

constraints:
  - "The number of nodes in the tree is in the range [0, 10^4]."
  - "-1000 <= Node.val <= 1000"

examples:
  - input: "root = [1,2,3,null,null,4,5]"
    output: "[1,2,3,null,null,4,5]"
  - input: "root = []"
    output: "[]"

languages:
  python:
    starter_code: |
      class Solution:
          def serializeDeserialize(self, root: List) -> List:
              pass
    reference_solution: |
      class Solution:
          def serializeDeserialize(self, root: List) -> List:
              # For testing, we verify round-trip: serialize then deserialize
              from collections import deque

              class TreeNode:
                  def __init__(self, val=0):
                      self.val = val
                      self.left = None
                      self.right = None

              def build_tree(arr):
                  if not arr or (len(arr) > 0 and arr[0] is None):
                      return None
                  if not arr:
                      return None
                  root = TreeNode(arr[0])
                  queue = deque([root])
                  i = 1
                  while queue and i < len(arr):
                      node = queue.popleft()
                      if i < len(arr) and arr[i] is not None:
                          node.left = TreeNode(arr[i])
                          queue.append(node.left)
                      i += 1
                      if i < len(arr) and arr[i] is not None:
                          node.right = TreeNode(arr[i])
                          queue.append(node.right)
                      i += 1
                  return root

              def serialize(node):
                  if not node:
                      return ""
                  result = []
                  queue = deque([node])
                  while queue:
                      curr = queue.popleft()
                      if curr:
                          result.append(str(curr.val))
                          queue.append(curr.left)
                          queue.append(curr.right)
                      else:
                          result.append("null")
                  # Remove trailing nulls
                  while result and result[-1] == "null":
                      result.pop()
                  return ",".join(result)

              def deserialize(data):
                  if not data:
                      return None
                  vals = data.split(",")
                  root = TreeNode(int(vals[0]))
                  queue = deque([root])
                  i = 1
                  while queue and i < len(vals):
                      node = queue.popleft()
                      if i < len(vals) and vals[i] != "null":
                          node.left = TreeNode(int(vals[i]))
                          queue.append(node.left)
                      i += 1
                      if i < len(vals) and vals[i] != "null":
                          node.right = TreeNode(int(vals[i]))
                          queue.append(node.right)
                      i += 1
                  return root

              def tree_to_array(node):
                  if not node:
                      return []
                  result = []
                  queue = deque([node])
                  while queue:
                      curr = queue.popleft()
                      if curr:
                          result.append(curr.val)
                          queue.append(curr.left)
                          queue.append(curr.right)
                      else:
                          result.append(None)
                  while result and result[-1] is None:
                      result.pop()
                  return result

              tree = build_tree(root)
              serialized = serialize(tree)
              deserialized = deserialize(serialized)
              return tree_to_array(deserialized)
    function_signature:
      name: serializeDeserialize
      params:
        - name: root
          type: List
      return_type: List

test_cases:
  - input: [[1, 2, 3, null, null, 4, 5]]
    expected: [1, 2, 3, null, null, 4, 5]
  - input: [[]]
    expected: []
  - input: [[1]]
    expected: [1]
  - input: [[1, 2]]
    expected: [1, 2]
  - input: [[1, null, 2]]
    expected: [1, null, 2]
  - input: [[1, 2, 3]]
    expected: [1, 2, 3]
  - input: [[1, 2, 3, 4, 5, 6, 7]]
    expected: [1, 2, 3, 4, 5, 6, 7]
  - input: [[-1, -2, -3]]
    expected: [-1, -2, -3]
  - input: [[0]]
    expected: [0]
  - input: [[1, null, 2, null, 3]]
    expected: [1, null, 2, null, 3]
  - input: [[5, 4, 7, 3, null, 2, null, -1, null, 9]]
    expected: [5, 4, 7, 3, null, 2, null, -1, null, 9]
  - input: [[1, 2, 3, null, null, 4, 5, 6, 7]]
    expected: [1, 2, 3, null, null, 4, 5, 6, 7]
  - input: [[100, 50, 150, 25, 75, 125, 175]]
    expected: [100, 50, 150, 25, 75, 125, 175]
  - input: [[1000, -1000]]
    expected: [1000, -1000]
  - input: [[1, 2, 3, 4, 5, null, null, 6]]
    expected: [1, 2, 3, 4, 5, null, null, 6]
