title: Count Good Nodes in Binary Tree
sequence_number: 96
difficulty: medium
pattern:
  - trees
  - depth-first-search
  - breadth-first-search

description: |
  Given a binary tree `root`, a node X in the tree is named **good** if in the path from root to X there are no nodes with a value greater than X.

  Return the number of **good** nodes in the binary tree.

  The tree is represented as a level-order array where `null` represents missing nodes.

constraints:
  - "The number of nodes in the binary tree is in the range [1, 10^5]."
  - "Each node's value is between [-10^4, 10^4]."

examples:
  - input: "root = [3,1,4,3,null,1,5]"
    output: "4"
    explanation: "Nodes in blue are good. Root Node (3) is always good. Node 4 -> (3,4) is good because 4 is the max. Node 5 -> (3,4,5) is good because 5 is max. Node 3 -> (3,1,3) is good because 3 is max."
  - input: "root = [3,3,null,4,2]"
    output: "3"
  - input: "root = [1]"
    output: "1"

languages:
  python:
    starter_code: |
      class Solution:
          def goodNodes(self, root: List) -> int:
              pass
    reference_solution: |
      class Solution:
          def goodNodes(self, root: List) -> int:
              if not root:
                  return 0

              # Build tree from array
              class TreeNode:
                  def __init__(self, val=0, left=None, right=None):
                      self.val = val
                      self.left = left
                      self.right = right

              def build_tree(arr):
                  if not arr or arr[0] is None:
                      return None
                  root = TreeNode(arr[0])
                  queue = [root]
                  i = 1
                  while queue and i < len(arr):
                      node = queue.pop(0)
                      if i < len(arr) and arr[i] is not None:
                          node.left = TreeNode(arr[i])
                          queue.append(node.left)
                      i += 1
                      if i < len(arr) and arr[i] is not None:
                          node.right = TreeNode(arr[i])
                          queue.append(node.right)
                      i += 1
                  return root

              tree_root = build_tree(root)
              count = 0

              def dfs(node, max_val):
                  nonlocal count
                  if not node:
                      return
                  if node.val >= max_val:
                      count += 1
                      max_val = node.val
                  dfs(node.left, max_val)
                  dfs(node.right, max_val)

              dfs(tree_root, float('-inf'))
              return count
    function_signature:
      name: goodNodes
      params:
        - name: root
          type: List
      return_type: int

test_cases:
  - input: [[3, 1, 4, 3, null, 1, 5]]
    expected: 4
  - input: [[3, 3, null, 4, 2]]
    expected: 3
  - input: [[1]]
    expected: 1
  - input: [[2, null, 4, 10, 8, null, null, 4]]
    expected: 4
  - input: [[9, null, 3, 6]]
    expected: 1
  - input: [[1, 2, 3]]
    expected: 3
  - input: [[3, 2, 1]]
    expected: 1
  - input: [[5, 5, 5, 5, 5, 5, 5]]
    expected: 7
  - input: [[1, 2, 3, 4, 5, 6, 7]]
    expected: 7
  - input: [[7, 6, 5, 4, 3, 2, 1]]
    expected: 1
  - input: [[-10, 9, -5, null, null, 6, -1]]
    expected: 5
  - input: [[0, 0, 0]]
    expected: 3
  - input: [[-1, -2, -3]]
    expected: 1
  - input: [[10, 5, 15, 3, 7, 13, 18]]
    expected: 3
  - input: [[4, 2, 6, 1, 3, 5, 7]]
    expected: 3
