title: Word Ladder
sequence_number: 115
difficulty: hard
pattern:
  - graph
  - breadth-first-search

description: |
  A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:
  - Every adjacent pair of words differs by a single letter.
  - Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
  - `sk == endWord`

  Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the **number of words** in the **shortest transformation sequence** from `beginWord` to `endWord`, or `0` if no such sequence exists.

constraints:
  - "1 <= beginWord.length <= 10"
  - "endWord.length == beginWord.length"
  - "1 <= wordList.length <= 5000"
  - "wordList[i].length == beginWord.length"
  - "beginWord, endWord, and wordList[i] consist of lowercase English letters."
  - "beginWord != endWord"
  - "All the words in wordList are unique."

examples:
  - input: 'beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]'
    output: "5"
    explanation: 'One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> "cog", which is 5 words long.'
  - input: 'beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]'
    output: "0"
    explanation: 'The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.'

languages:
  python:
    starter_code: |
      class Solution:
          def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
              pass
    reference_solution: |
      class Solution:
          def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
              from collections import deque

              if endWord not in wordList:
                  return 0

              word_set = set(wordList)
              queue = deque([(beginWord, 1)])
              visited = {beginWord}

              while queue:
                  word, length = queue.popleft()
                  if word == endWord:
                      return length

                  for i in range(len(word)):
                      for c in 'abcdefghijklmnopqrstuvwxyz':
                          new_word = word[:i] + c + word[i+1:]
                          if new_word in word_set and new_word not in visited:
                              visited.add(new_word)
                              queue.append((new_word, length + 1))

              return 0
    function_signature:
      name: ladderLength
      params:
        - name: beginWord
          type: str
        - name: endWord
          type: str
        - name: wordList
          type: "List[str]"
      return_type: int

test_cases:
  - input: ["hit", "cog", ["hot","dot","dog","lot","log","cog"]]
    expected: 5
  - input: ["hit", "cog", ["hot","dot","dog","lot","log"]]
    expected: 0
  - input: ["a", "c", ["a","b","c"]]
    expected: 2
  - input: ["hot", "dog", ["hot","dog"]]
    expected: 0
  - input: ["hot", "dog", ["hot","dot","dog"]]
    expected: 3
  - input: ["leet", "code", ["lest","leet","lose","code","lode","robe","lost"]]
    expected: 6
  - input: ["talk", "tail", ["talk","tall","tail"]]
    expected: 3
  - input: ["red", "tax", ["ted","tex","red","tax","tad","den","rex","pee"]]
    expected: 4
  - input: ["game", "thee", ["frye","heat","tree","thee","game","free","hell","fame","faye"]]
    expected: 7
  - input: ["sand", "acne", ["sand","acnd","acne","rand","rann","racn","rack","sack","sane"]]
    expected: 0
  - input: ["ab", "cd", ["ab","ad","cd"]]
    expected: 3
  - input: ["qa", "sq", ["si","go","se","cm","so","ph","os","sq"]]
    expected: 0
