title: Course Schedule II
sequence_number: 113
difficulty: medium
pattern:
  - graph
  - topological-sort
  - depth-first-search
  - breadth-first-search

description: |
  There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

  For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

  Return the ordering of courses you should take to finish all courses. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.

constraints:
  - "1 <= numCourses <= 2000"
  - "0 <= prerequisites.length <= numCourses * (numCourses - 1)"
  - "prerequisites[i].length == 2"
  - "0 <= ai, bi < numCourses"
  - "ai != bi"
  - "All the pairs [ai, bi] are distinct."

examples:
  - input: "numCourses = 2, prerequisites = [[1,0]]"
    output: "[0,1]"
    explanation: "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]."
  - input: "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]"
    output: "[0,2,1,3]"
    explanation: "There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]."
  - input: "numCourses = 1, prerequisites = []"
    output: "[0]"

languages:
  python:
    starter_code: |
      class Solution:
          def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
              pass
    reference_solution: |
      class Solution:
          def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
              from collections import defaultdict, deque

              # Build adjacency list and in-degree count
              graph = defaultdict(list)
              in_degree = [0] * numCourses

              for course, prereq in prerequisites:
                  graph[prereq].append(course)
                  in_degree[course] += 1

              # Start with courses that have no prerequisites
              queue = deque([i for i in range(numCourses) if in_degree[i] == 0])
              result = []

              while queue:
                  course = queue.popleft()
                  result.append(course)
                  for next_course in graph[course]:
                      in_degree[next_course] -= 1
                      if in_degree[next_course] == 0:
                          queue.append(next_course)

              return result if len(result) == numCourses else []
    function_signature:
      name: findOrder
      params:
        - name: numCourses
          type: int
        - name: prerequisites
          type: "List[List[int]]"
      return_type: "List[int]"

test_cases:
  - input: [2, [[1,0]]]
    expected: [0, 1]
  - input: [4, [[1,0],[2,0],[3,1],[3,2]]]
    expected: [0, 1, 2, 3]
  - input: [1, []]
    expected: [0]
  - input: [2, [[0,1],[1,0]]]
    expected: []
  - input: [3, [[1,0],[2,1]]]
    expected: [0, 1, 2]
  - input: [3, []]
    expected: [0, 1, 2]
  - input: [2, []]
    expected: [0, 1]
  - input: [4, [[1,0],[2,1],[3,2]]]
    expected: [0, 1, 2, 3]
  - input: [3, [[0,1],[0,2],[1,2]]]
    expected: [2, 1, 0]
  - input: [5, [[1,0],[2,0],[3,1],[3,2],[4,3]]]
    expected: [0, 1, 2, 3, 4]
  - input: [3, [[1,0],[2,0]]]
    expected: [0, 1, 2]
  - input: [4, [[0,1],[1,2],[2,3],[3,0]]]
    expected: []
  - input: [2, [[1,0],[0,1]]]
    expected: []
  - input: [6, [[1,0],[2,1],[3,2],[4,2],[5,3],[5,4]]]
    expected: [0, 1, 2, 3, 4, 5]
