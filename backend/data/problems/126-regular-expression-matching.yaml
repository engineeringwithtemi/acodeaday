title: Regular Expression Matching
sequence_number: 126
difficulty: hard
pattern:
  - dynamic-programming
  - string
  - recursion

description: |
  Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:
  - `'.'` Matches any single character.
  - `'*'` Matches zero or more of the preceding element.

  The matching should cover the **entire** input string (not partial).

constraints:
  - "1 <= s.length <= 20"
  - "1 <= p.length <= 20"
  - "s contains only lowercase English letters."
  - "p contains only lowercase English letters, '.', and '*'."
  - "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."

examples:
  - input: 's = "aa", p = "a"'
    output: "false"
    explanation: '"a" does not match the entire string "aa".'
  - input: 's = "aa", p = "a*"'
    output: "true"
    explanation: '"*" means zero or more of the preceding element "a". Therefore, by repeating "a" once, it becomes "aa".'
  - input: 's = "ab", p = ".*"'
    output: "true"
    explanation: '".*" means "zero or more (*) of any character (.)".'

languages:
  python:
    starter_code: |
      class Solution:
          def isMatch(self, s: str, p: str) -> bool:
              pass
    reference_solution: |
      class Solution:
          def isMatch(self, s: str, p: str) -> bool:
              m, n = len(s), len(p)
              dp = [[False] * (n + 1) for _ in range(m + 1)]
              dp[0][0] = True

              # Handle patterns like a*, a*b*, a*b*c* that can match empty string
              for j in range(2, n + 1):
                  if p[j-1] == '*':
                      dp[0][j] = dp[0][j-2]

              for i in range(1, m + 1):
                  for j in range(1, n + 1):
                      if p[j-1] == '*':
                          # Zero occurrences of preceding char
                          dp[i][j] = dp[i][j-2]
                          # One or more occurrences if chars match
                          if p[j-2] == '.' or p[j-2] == s[i-1]:
                              dp[i][j] = dp[i][j] or dp[i-1][j]
                      elif p[j-1] == '.' or p[j-1] == s[i-1]:
                          dp[i][j] = dp[i-1][j-1]

              return dp[m][n]
    function_signature:
      name: isMatch
      params:
        - name: s
          type: str
        - name: p
          type: str
      return_type: bool

test_cases:
  - input: ["aa", "a"]
    expected: false
  - input: ["aa", "a*"]
    expected: true
  - input: ["ab", ".*"]
    expected: true
  - input: ["aab", "c*a*b"]
    expected: true
  - input: ["mississippi", "mis*is*p*."]
    expected: false
  - input: ["a", "a"]
    expected: true
  - input: ["a", "."]
    expected: true
  - input: ["a", ".*"]
    expected: true
  - input: ["ab", "a."]
    expected: true
  - input: ["ab", ".."]
    expected: true
  - input: ["aaa", "a*"]
    expected: true
  - input: ["aaa", "aa*"]
    expected: true
  - input: ["aaa", "a*a"]
    expected: true
  - input: ["ab", ".*c"]
    expected: false
  - input: ["aab", "a*b"]
    expected: true
