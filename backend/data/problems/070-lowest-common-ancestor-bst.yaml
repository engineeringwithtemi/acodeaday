title: Lowest Common Ancestor of a BST
sequence_number: 70
difficulty: medium
pattern:
  - tree
  - bst
  - recursion

description: |
  Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

  According to the definition of LCA on Wikipedia: "The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**)."

  For testing purposes, binary trees are represented as arrays in level-order (BFS), where `null` represents missing nodes.

constraints:
  - "The number of nodes in the tree is in the range [2, 10^5]."
  - "-10^9 <= Node.val <= 10^9"
  - "All Node.val are unique."
  - "p != q"
  - "p and q will exist in the BST."

examples:
  - input: "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8"
    output: "6"
  - input: "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4"
    output: "2"

languages:
  python:
    starter_code: |
      class Solution:
          def lowestCommonAncestor(self, root: List, p: int, q: int) -> int:
              pass
    reference_solution: |
      class Solution:
          def lowestCommonAncestor(self, root: List, p: int, q: int) -> int:
              from collections import deque

              class TreeNode:
                  def __init__(self, val=0):
                      self.val = val
                      self.left = None
                      self.right = None

              def build_tree(arr):
                  if not arr or arr[0] is None:
                      return None
                  root = TreeNode(arr[0])
                  queue = deque([root])
                  i = 1
                  while queue and i < len(arr):
                      node = queue.popleft()
                      if i < len(arr) and arr[i] is not None:
                          node.left = TreeNode(arr[i])
                          queue.append(node.left)
                      i += 1
                      if i < len(arr) and arr[i] is not None:
                          node.right = TreeNode(arr[i])
                          queue.append(node.right)
                      i += 1
                  return root

              tree = build_tree(root)
              node = tree

              while node:
                  if p < node.val and q < node.val:
                      node = node.left
                  elif p > node.val and q > node.val:
                      node = node.right
                  else:
                      return node.val

              return -1
    function_signature:
      name: lowestCommonAncestor
      params:
        - name: root
          type: List
        - name: p
          type: int
        - name: q
          type: int
      return_type: int

test_cases:
  - input: [[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], 2, 8]
    expected: 6
  - input: [[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], 2, 4]
    expected: 2
  - input: [[2, 1], 2, 1]
    expected: 2
  - input: [[2, 1, 3], 1, 3]
    expected: 2
  - input: [[5, 3, 7, 2, 4, 6, 8], 2, 4]
    expected: 3
  - input: [[5, 3, 7, 2, 4, 6, 8], 6, 8]
    expected: 7
  - input: [[5, 3, 7, 2, 4, 6, 8], 2, 8]
    expected: 5
  - input: [[5, 3, 7, 2, 4, 6, 8], 3, 7]
    expected: 5
  - input: [[5, 3, 7, 2, 4, 6, 8], 2, 3]
    expected: 3
  - input: [[5, 3, 7, 2, 4, 6, 8], 7, 8]
    expected: 7
  - input: [[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], 3, 5]
    expected: 4
  - input: [[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], 0, 5]
    expected: 2
  - input: [[20, 10, 30, 5, 15, 25, 35], 5, 15]
    expected: 10
  - input: [[20, 10, 30, 5, 15, 25, 35], 25, 35]
    expected: 30
  - input: [[20, 10, 30, 5, 15, 25, 35], 5, 35]
    expected: 20
