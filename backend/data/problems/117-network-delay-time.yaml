title: Network Delay Time
sequence_number: 117
difficulty: medium
pattern:
  - graph
  - shortest-path
  - heap

description: |
  You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.

  We will send a signal from a given node `k`. Return the **minimum** time it takes for all the `n` nodes to receive the signal. If it is impossible for all the `n` nodes to receive the signal, return `-1`.

constraints:
  - "1 <= k <= n <= 100"
  - "1 <= times.length <= 6000"
  - "times[i].length == 3"
  - "1 <= ui, vi <= n"
  - "ui != vi"
  - "0 <= wi <= 100"
  - "All the pairs (ui, vi) are unique. (i.e., no multiple edges.)"

examples:
  - input: "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2"
    output: "2"
  - input: "times = [[1,2,1]], n = 2, k = 1"
    output: "1"
  - input: "times = [[1,2,1]], n = 2, k = 2"
    output: "-1"

languages:
  python:
    starter_code: |
      class Solution:
          def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
              pass
    reference_solution: |
      class Solution:
          def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
              import heapq
              from collections import defaultdict

              # Build adjacency list
              graph = defaultdict(list)
              for u, v, w in times:
                  graph[u].append((v, w))

              # Dijkstra's algorithm
              dist = {k: 0}
              heap = [(0, k)]

              while heap:
                  time, node = heapq.heappop(heap)
                  if time > dist.get(node, float('inf')):
                      continue
                  for neighbor, weight in graph[node]:
                      new_time = time + weight
                      if new_time < dist.get(neighbor, float('inf')):
                          dist[neighbor] = new_time
                          heapq.heappush(heap, (new_time, neighbor))

              if len(dist) == n:
                  return max(dist.values())
              return -1
    function_signature:
      name: networkDelayTime
      params:
        - name: times
          type: "List[List[int]]"
        - name: n
          type: int
        - name: k
          type: int
      return_type: int

test_cases:
  - input: [[[2,1,1],[2,3,1],[3,4,1]], 4, 2]
    expected: 2
  - input: [[[1,2,1]], 2, 1]
    expected: 1
  - input: [[[1,2,1]], 2, 2]
    expected: -1
  - input: [[[1,2,1],[2,1,1]], 2, 1]
    expected: 1
  - input: [[[1,2,1],[2,3,2],[3,4,3]], 4, 1]
    expected: 6
  - input: [[[1,2,1],[1,3,2],[2,3,1]], 3, 1]
    expected: 2
  - input: [[[1,2,1],[2,3,1],[1,3,4]], 3, 1]
    expected: 2
  - input: [[[1,2,1],[1,3,1],[1,4,1]], 4, 1]
    expected: 1
  - input: [[[1,2,5],[2,3,5],[3,4,5]], 4, 1]
    expected: 15
  - input: [[[1,2,1],[2,3,2],[3,1,3]], 3, 1]
    expected: 3
  - input: [[[1,2,0],[2,3,0]], 3, 1]
    expected: 0
  - input: [[[1,2,100],[2,3,100],[3,4,100]], 4, 1]
    expected: 300
