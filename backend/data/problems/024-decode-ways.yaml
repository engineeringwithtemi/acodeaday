title: Decode Ways
sequence_number: 24
difficulty: medium
pattern:
  - dynamic-programming
  - string
  - memoization
  - counting

description: |
  A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:

  ```
  'A' -> "1"
  'B' -> "2"
  ...
  'Z' -> "26"
  ```

  To **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `"11106"` can be mapped into:
  - `"AAJF"` with the grouping `(1 1 10 6)`
  - `"KJF"` with the grouping `(11 10 6)`

  Note that the grouping `(1 11 06)` is invalid because `"06"` cannot be mapped into `'F'` since `"6"` is different from `"06"`.

  Given a string `s` containing only digits, return the **number of ways** to **decode** it.

  The test cases are generated so that the answer fits in a **32-bit** integer.

constraints:
  - "1 <= s.length <= 100"
  - "s contains only digits and may contain leading zero(s)."

examples:
  - input: 's = "12"'
    output: "2"
    explanation: '"12" could be decoded as "AB" (1 2) or "L" (12).'
  - input: 's = "226"'
    output: "3"
    explanation: '"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).'
  - input: 's = "06"'
    output: "0"
    explanation: '"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06").'

languages:
  python:
    starter_code: |
      class Solution:
          def numDecodings(self, s: str) -> int:
              pass
    reference_solution: |
      class Solution:
          def numDecodings(self, s: str) -> int:
              if not s or s[0] == '0':
                  return 0

              n = len(s)
              # dp[i] = number of ways to decode s[:i]
              dp = [0] * (n + 1)
              dp[0] = 1  # empty string
              dp[1] = 1  # first char is not '0'

              for i in range(2, n + 1):
                  # Single digit decode (1-9)
                  if s[i - 1] != '0':
                      dp[i] += dp[i - 1]

                  # Two digit decode (10-26)
                  two_digit = int(s[i - 2:i])
                  if 10 <= two_digit <= 26:
                      dp[i] += dp[i - 2]

              return dp[n]
    function_signature:
      name: numDecodings
      params:
        - name: s
          type: str
      return_type: int

test_cases:
  - input: ["12"]
    expected: 2
  - input: ["226"]
    expected: 3
  - input: ["06"]
    expected: 0
  - input: ["1"]
    expected: 1
  - input: ["0"]
    expected: 0
  - input: ["10"]
    expected: 1
  - input: ["11"]
    expected: 2
  - input: ["27"]
    expected: 1
  - input: ["100"]
    expected: 0
  - input: ["101"]
    expected: 1
  - input: ["110"]
    expected: 1
  - input: ["111"]
    expected: 3
  - input: ["1111"]
    expected: 5
  - input: ["11111"]
    expected: 8
  - input: ["2611055971756562"]
    expected: 4
  - input: ["123"]
    expected: 3
  - input: ["1234"]
    expected: 3
  - input: ["12345"]
    expected: 3
  - input: ["11106"]
    expected: 2
  - input: ["301"]
    expected: 0
  - input: ["230"]
    expected: 0
  - input: ["2101"]
    expected: 1
  - input: ["1201234"]
    expected: 3
  - input: ["99999"]
    expected: 1
  - input: ["111111111111111111111111111111111111111111111"]
    expected: 1836311903
