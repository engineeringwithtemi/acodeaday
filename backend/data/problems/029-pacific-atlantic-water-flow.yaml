title: Pacific Atlantic Water Flow
sequence_number: 29
difficulty: medium
pattern:
  - graph
  - bfs
  - dfs
  - matrix

description: |
  There is an `m x n` rectangular island that borders both the **Pacific Ocean** and **Atlantic Ocean**. The **Pacific Ocean** touches the island's left and top edges, and the **Atlantic Ocean** touches the island's right and bottom edges.

  The island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`.

  The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.

  Return a **2D list** of grid coordinates `result` where `result[i] = [ri, ci]` denotes that rain water can flow from cell `(ri, ci)` to **both** the Pacific and Atlantic oceans.

constraints:
  - "m == heights.length"
  - "n == heights[r].length"
  - "1 <= m, n <= 200"
  - "0 <= heights[r][c] <= 10^5"

examples:
  - input: "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]"
    output: "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
    explanation: "The following cells can flow to both oceans: [0,4], [1,3], [1,4], [2,2], [3,0], [3,1], [4,0]"
  - input: "heights = [[1]]"
    output: "[[0,0]]"

languages:
  python:
    starter_code: |
      class Solution:
          def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
              pass
    reference_solution: |
      class Solution:
          def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
              if not heights:
                  return []

              m, n = len(heights), len(heights[0])
              pacific = set()
              atlantic = set()

              def dfs(r, c, visited, prev_height):
                  if (r, c) in visited or r < 0 or r >= m or c < 0 or c >= n:
                      return
                  if heights[r][c] < prev_height:
                      return
                  visited.add((r, c))
                  for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                      dfs(r + dr, c + dc, visited, heights[r][c])

              # Start from Pacific edges (top and left)
              for c in range(n):
                  dfs(0, c, pacific, 0)
              for r in range(m):
                  dfs(r, 0, pacific, 0)

              # Start from Atlantic edges (bottom and right)
              for c in range(n):
                  dfs(m - 1, c, atlantic, 0)
              for r in range(m):
                  dfs(r, n - 1, atlantic, 0)

              # Find intersection
              result = sorted([[r, c] for r, c in pacific & atlantic])
              return result
    function_signature:
      name: pacificAtlantic
      params:
        - name: heights
          type: "List[List[int]]"
      return_type: "List[List[int]]"

test_cases:
  - input: [[[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]]
    expected: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]
  - input: [[[1]]]
    expected: [[0, 0]]
  - input: [[[1, 1], [1, 1]]]
    expected: [[0, 0], [0, 1], [1, 0], [1, 1]]
  - input: [[[1, 2], [2, 1]]]
    expected: [[0, 1], [1, 0]]
  - input: [[[3, 3, 3], [3, 1, 3], [3, 3, 3]]]
    expected: [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]]
  - input: [[[1, 2, 3], [8, 9, 4], [7, 6, 5]]]
    expected: [[0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
  - input: [[[10, 10, 10], [10, 1, 10], [10, 10, 10]]]
    expected: [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]]
  - input: [[[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]]
    expected: [[0, 3], [1, 0], [1, 1], [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]]
  - input: [[[5]]]
    expected: [[0, 0]]
  - input: [[[1, 1, 1, 1, 1]]]
    expected: [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4]]
  - input: [[[1], [1], [1], [1], [1]]]
    expected: [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0]]
  - input: [[[5, 1], [1, 5]]]
    expected: [[0, 0], [0, 1], [1, 0], [1, 1]]
  - input: [[[2, 1], [1, 2]]]
    expected: [[0, 0], [0, 1], [1, 0], [1, 1]]
  - input: [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]
    expected: [[0, 2], [1, 2], [2, 0], [2, 1], [2, 2]]
  - input: [[[9, 8, 7], [6, 5, 4], [3, 2, 1]]]
    expected: [[0, 0], [0, 1], [0, 2], [1, 0], [2, 0]]
