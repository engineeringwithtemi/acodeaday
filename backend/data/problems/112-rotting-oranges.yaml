title: Rotting Oranges
sequence_number: 112
difficulty: medium
pattern:
  - graph
  - breadth-first-search
  - matrix

description: |
  You are given an `m x n` grid where each cell can have one of three values:
  - `0` representing an empty cell,
  - `1` representing a fresh orange, or
  - `2` representing a rotten orange.

  Every minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.

  Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return `-1`.

constraints:
  - "m == grid.length"
  - "n == grid[i].length"
  - "1 <= m, n <= 10"
  - "grid[i][j] is 0, 1, or 2."

examples:
  - input: "grid = [[2,1,1],[1,1,0],[0,1,1]]"
    output: "4"
  - input: "grid = [[2,1,1],[0,1,1],[1,0,1]]"
    output: "-1"
    explanation: "The orange in the bottom left corner (row 2, column 0) is never rotten because rotting only happens 4-directionally."
  - input: "grid = [[0,2]]"
    output: "0"
    explanation: "Since there are no fresh oranges at minute 0, the answer is 0."

languages:
  python:
    starter_code: |
      class Solution:
          def orangesRotting(self, grid: List[List[int]]) -> int:
              pass
    reference_solution: |
      class Solution:
          def orangesRotting(self, grid: List[List[int]]) -> int:
              from collections import deque

              m, n = len(grid), len(grid[0])
              queue = deque()
              fresh = 0

              # Find all rotten oranges and count fresh ones
              for i in range(m):
                  for j in range(n):
                      if grid[i][j] == 2:
                          queue.append((i, j))
                      elif grid[i][j] == 1:
                          fresh += 1

              if fresh == 0:
                  return 0

              minutes = 0
              directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

              while queue:
                  minutes += 1
                  for _ in range(len(queue)):
                      x, y = queue.popleft()
                      for dx, dy in directions:
                          nx, ny = x + dx, y + dy
                          if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
                              grid[nx][ny] = 2
                              fresh -= 1
                              queue.append((nx, ny))

              return minutes - 1 if fresh == 0 else -1
    function_signature:
      name: orangesRotting
      params:
        - name: grid
          type: "List[List[int]]"
      return_type: int

test_cases:
  - input: [[[2,1,1],[1,1,0],[0,1,1]]]
    expected: 4
  - input: [[[2,1,1],[0,1,1],[1,0,1]]]
    expected: -1
  - input: [[[0,2]]]
    expected: 0
  - input: [[[0]]]
    expected: 0
  - input: [[[1]]]
    expected: -1
  - input: [[[2]]]
    expected: 0
  - input: [[[2,2],[1,1]]]
    expected: 1
  - input: [[[1,2]]]
    expected: 1
  - input: [[[2,1,1],[1,1,1],[0,1,2]]]
    expected: 2
  - input: [[[0,0,0],[0,0,0],[0,0,0]]]
    expected: 0
  - input: [[[1,1,1],[1,1,1],[1,1,1]]]
    expected: -1
  - input: [[[2,0,1,0,2]]]
    expected: -1
  - input: [[[2,1,0,1,2]]]
    expected: 1
  - input: [[[1,2,1,1,2,1,1]]]
    expected: 2
  - input: [[[2,1,1,1,1],[0,0,0,0,1],[1,1,1,1,1]]]
    expected: 10
