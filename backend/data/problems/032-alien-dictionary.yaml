title: Alien Dictionary
sequence_number: 32
difficulty: hard
pattern:
  - graph
  - topological-sort
  - string

description: |
  There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.

  You are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are **sorted lexicographically** by the rules of this new language.

  Derive the order of letters in this language, and return it. If the given input is invalid, return `""`. If there are multiple valid solutions, return **any of them**.

  A string `s` is **lexicographically smaller** than string `t` if at the first letter where they differ, the letter in `s` comes before the letter in `t` in the alien language. If the first `min(s.length, t.length)` letters are the same, then `s` is smaller if and only if `s.length < t.length`.

constraints:
  - "1 <= words.length <= 100"
  - "1 <= words[i].length <= 100"
  - "words[i] consists of only lowercase English letters."

examples:
  - input: 'words = ["wrt","wrf","er","ett","rftt"]'
    output: '"wertf"'
    explanation: "From 'wrt' and 'wrf', we know 't' comes before 'f'. From 'wrt' and 'er', we know 'w' comes before 'e'. From 'er' and 'ett', we know 'r' comes before 't'. From 'ett' and 'rftt', we know 'e' comes before 'r'. So one valid order is 'wertf'."
  - input: 'words = ["z","x"]'
    output: '"zx"'
  - input: 'words = ["z","x","z"]'
    output: '""'
    explanation: "The order is invalid, so return ''."

languages:
  python:
    starter_code: |
      class Solution:
          def alienOrder(self, words: List[str]) -> str:
              pass
    reference_solution: |
      class Solution:
          def alienOrder(self, words: List[str]) -> str:
              from collections import defaultdict, deque

              # Build graph with all characters
              in_degree = {c: 0 for word in words for c in word}
              graph = defaultdict(set)

              # Build edges from adjacent word pairs
              for i in range(len(words) - 1):
                  w1, w2 = words[i], words[i + 1]
                  min_len = min(len(w1), len(w2))

                  # Invalid case: longer word comes before shorter prefix
                  if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:
                      return ""

                  for j in range(min_len):
                      if w1[j] != w2[j]:
                          if w2[j] not in graph[w1[j]]:
                              graph[w1[j]].add(w2[j])
                              in_degree[w2[j]] += 1
                          break

              # Kahn's algorithm for topological sort
              queue = deque([c for c in in_degree if in_degree[c] == 0])
              result = []

              while queue:
                  c = queue.popleft()
                  result.append(c)
                  for neighbor in sorted(graph[c]):
                      in_degree[neighbor] -= 1
                      if in_degree[neighbor] == 0:
                          queue.append(neighbor)

              # Check for cycle
              if len(result) != len(in_degree):
                  return ""

              return "".join(result)
    function_signature:
      name: alienOrder
      params:
        - name: words
          type: "List[str]"
      return_type: str

test_cases:
  - input: [["wrt", "wrf", "er", "ett", "rftt"]]
    expected: "wertf"
  - input: [["z", "x"]]
    expected: "zx"
  - input: [["z", "x", "z"]]
    expected: ""
  - input: [["abc", "ab"]]
    expected: ""
  - input: [["z"]]
    expected: "z"
  - input: [["a", "b", "c"]]
    expected: "abc"
  - input: [["z", "z"]]
    expected: "z"
  - input: [["a", "b", "a"]]
    expected: ""
  - input: [["x", "y", "x"]]
    expected: ""
  - input: [["a", "aa", "aaa"]]
    expected: "a"
  - input: [["aaa", "aa", "a"]]
    expected: ""
  - input: [["ab", "ba"]]
    expected: "ab"
  - input: [["zy", "zx"]]
    expected: "zyx"
  - input: [["abc"]]
    expected: "abc"
  - input: [["ac", "ab", "b"]]
    expected: "acb"
