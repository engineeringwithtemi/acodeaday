title: Longest Increasing Path in a Matrix
sequence_number: 127
difficulty: hard
pattern:
  - dynamic-programming
  - depth-first-search
  - memoization
  - matrix

description: |
  Given an `m x n` integers `matrix`, return the length of the longest increasing path in `matrix`.

  From each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).

constraints:
  - "m == matrix.length"
  - "n == matrix[i].length"
  - "1 <= m, n <= 200"
  - "0 <= matrix[i][j] <= 2^31 - 1"

examples:
  - input: "matrix = [[9,9,4],[6,6,8],[2,1,1]]"
    output: "4"
    explanation: "The longest increasing path is [1, 2, 6, 9]."
  - input: "matrix = [[3,4,5],[3,2,6],[2,2,1]]"
    output: "4"
    explanation: "The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed."
  - input: "matrix = [[1]]"
    output: "1"

languages:
  python:
    starter_code: |
      class Solution:
          def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
              pass
    reference_solution: |
      class Solution:
          def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
              if not matrix:
                  return 0

              m, n = len(matrix), len(matrix[0])
              memo = [[0] * n for _ in range(m)]
              directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

              def dfs(i, j):
                  if memo[i][j]:
                      return memo[i][j]

                  max_path = 1
                  for di, dj in directions:
                      ni, nj = i + di, j + dj
                      if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                          max_path = max(max_path, 1 + dfs(ni, nj))

                  memo[i][j] = max_path
                  return max_path

              result = 0
              for i in range(m):
                  for j in range(n):
                      result = max(result, dfs(i, j))

              return result
    function_signature:
      name: longestIncreasingPath
      params:
        - name: matrix
          type: "List[List[int]]"
      return_type: int

test_cases:
  - input: [[[9,9,4],[6,6,8],[2,1,1]]]
    expected: 4
  - input: [[[3,4,5],[3,2,6],[2,2,1]]]
    expected: 4
  - input: [[[1]]]
    expected: 1
  - input: [[[1,2]]]
    expected: 2
  - input: [[[2,1]]]
    expected: 2
  - input: [[[1,2,3]]]
    expected: 3
  - input: [[[1],[2],[3]]]
    expected: 3
  - input: [[[1,2],[4,3]]]
    expected: 4
  - input: [[[7,8,9],[6,1,2],[5,4,3]]]
    expected: 9
  - input: [[[1,1,1],[1,1,1],[1,1,1]]]
    expected: 1
  - input: [[[1,2,3],[8,9,4],[7,6,5]]]
    expected: 9
  - input: [[[0,1,2,3,4,5,6,7,8,9]]]
    expected: 10
