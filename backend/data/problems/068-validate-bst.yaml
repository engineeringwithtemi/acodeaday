title: Validate Binary Search Tree
sequence_number: 68
difficulty: medium
pattern:
  - tree
  - dfs
  - bst

description: |
  Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).

  A **valid BST** is defined as follows:
  - The left subtree of a node contains only nodes with keys **less than** the node's key.
  - The right subtree of a node contains only nodes with keys **greater than** the node's key.
  - Both the left and right subtrees must also be binary search trees.

  For testing purposes, binary trees are represented as arrays in level-order (BFS), where `null` represents missing nodes.

constraints:
  - "The number of nodes in the tree is in the range [1, 10^4]."
  - "-2^31 <= Node.val <= 2^31 - 1"

examples:
  - input: "root = [2,1,3]"
    output: "true"
  - input: "root = [5,1,4,null,null,3,6]"
    output: "false"
    explanation: "The root node's value is 5 but its right child's value is 4."

languages:
  python:
    starter_code: |
      class Solution:
          def isValidBST(self, root: List) -> bool:
              pass
    reference_solution: |
      class Solution:
          def isValidBST(self, root: List) -> bool:
              from collections import deque

              class TreeNode:
                  def __init__(self, val=0):
                      self.val = val
                      self.left = None
                      self.right = None

              def build_tree(arr):
                  if not arr or arr[0] is None:
                      return None
                  root = TreeNode(arr[0])
                  queue = deque([root])
                  i = 1
                  while queue and i < len(arr):
                      node = queue.popleft()
                      if i < len(arr) and arr[i] is not None:
                          node.left = TreeNode(arr[i])
                          queue.append(node.left)
                      i += 1
                      if i < len(arr) and arr[i] is not None:
                          node.right = TreeNode(arr[i])
                          queue.append(node.right)
                      i += 1
                  return root

              def validate(node, low=float('-inf'), high=float('inf')):
                  if not node:
                      return True
                  if node.val <= low or node.val >= high:
                      return False
                  return (validate(node.left, low, node.val) and
                          validate(node.right, node.val, high))

              tree = build_tree(root)
              return validate(tree)
    function_signature:
      name: isValidBST
      params:
        - name: root
          type: List
      return_type: bool

test_cases:
  - input: [[2, 1, 3]]
    expected: true
  - input: [[5, 1, 4, null, null, 3, 6]]
    expected: false
  - input: [[1]]
    expected: true
  - input: [[1, 1]]
    expected: false
  - input: [[2, 2, 2]]
    expected: false
  - input: [[5, 4, 6, null, null, 3, 7]]
    expected: false
  - input: [[10, 5, 15, null, null, 6, 20]]
    expected: false
  - input: [[3, 1, 5, 0, 2, 4, 6]]
    expected: true
  - input: [[1, null, 2]]
    expected: true
  - input: [[2, 1]]
    expected: true
  - input: [[1, null, 1]]
    expected: false
  - input: [[5, 3, 7, 2, 4, 6, 8]]
    expected: true
  - input: [[5, 3, 7, 2, 6, 6, 8]]
    expected: false
  - input: [[0, -1]]
    expected: true
  - input: [[120, 70, 140, 50, 100, 130, 160, 20, 55, 75, 110, 119, 135, 150, 200]]
    expected: false
