title: Binary Tree Maximum Path Sum
sequence_number: 63
difficulty: hard
pattern:
  - tree
  - dfs
  - dynamic-programming

description: |
  A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.

  The **path sum** of a path is the sum of the node's values in the path.

  Given the `root` of a binary tree, return the maximum **path sum** of any **non-empty** path.

  For testing purposes, binary trees are represented as arrays in level-order (BFS), where `null` represents missing nodes.

constraints:
  - "The number of nodes in the tree is in the range [1, 3 * 10^4]."
  - "-1000 <= Node.val <= 1000"

examples:
  - input: "root = [1,2,3]"
    output: "6"
    explanation: "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6."
  - input: "root = [-10,9,20,null,null,15,7]"
    output: "42"
    explanation: "The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."

languages:
  python:
    starter_code: |
      class Solution:
          def maxPathSum(self, root: List) -> int:
              pass
    reference_solution: |
      class Solution:
          def maxPathSum(self, root: List) -> int:
              from collections import deque

              class TreeNode:
                  def __init__(self, val=0):
                      self.val = val
                      self.left = None
                      self.right = None

              def build_tree(arr):
                  if not arr or arr[0] is None:
                      return None
                  root = TreeNode(arr[0])
                  queue = deque([root])
                  i = 1
                  while queue and i < len(arr):
                      node = queue.popleft()
                      if i < len(arr) and arr[i] is not None:
                          node.left = TreeNode(arr[i])
                          queue.append(node.left)
                      i += 1
                      if i < len(arr) and arr[i] is not None:
                          node.right = TreeNode(arr[i])
                          queue.append(node.right)
                      i += 1
                  return root

              max_sum = float('-inf')

              def max_gain(node):
                  nonlocal max_sum
                  if not node:
                      return 0

                  left_gain = max(max_gain(node.left), 0)
                  right_gain = max(max_gain(node.right), 0)

                  path_sum = node.val + left_gain + right_gain
                  max_sum = max(max_sum, path_sum)

                  return node.val + max(left_gain, right_gain)

              tree = build_tree(root)
              max_gain(tree)
              return max_sum
    function_signature:
      name: maxPathSum
      params:
        - name: root
          type: List
      return_type: int

test_cases:
  - input: [[1, 2, 3]]
    expected: 6
  - input: [[-10, 9, 20, null, null, 15, 7]]
    expected: 42
  - input: [[1]]
    expected: 1
  - input: [[-3]]
    expected: -3
  - input: [[2, -1]]
    expected: 2
  - input: [[-1, -2, -3]]
    expected: -1
  - input: [[5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1]]
    expected: 48
  - input: [[1, 2, null, 3]]
    expected: 6
  - input: [[1, -2, 3]]
    expected: 4
  - input: [[1, 2, 3, 4, 5]]
    expected: 11
  - input: [[-1, 5, null, 4, null, null, 2, -4]]
    expected: 11
  - input: [[9, 6, -3, null, null, -6, 2, null, null, 2, null, -6, -6, -6]]
    expected: 16
  - input: [[0]]
    expected: 0
  - input: [[1, null, 2, null, 3]]
    expected: 6
  - input: [[-2, -1]]
    expected: -1
