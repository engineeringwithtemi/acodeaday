title: Word Break
sequence_number: 20
difficulty: medium
pattern:
  - dynamic-programming
  - memoization
  - string
  - hash-set

description: |
  Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.

  **Note** that the same word in the dictionary may be reused multiple times in the segmentation.

constraints:
  - "1 <= s.length <= 300"
  - "1 <= wordDict.length <= 1000"
  - "1 <= wordDict[i].length <= 20"
  - "s and wordDict[i] consist of only lowercase English letters."
  - "All the strings of wordDict are unique."

examples:
  - input: 's = "leetcode", wordDict = ["leet","code"]'
    output: "true"
    explanation: 'Return true because "leetcode" can be segmented as "leet code".'
  - input: 's = "applepenapple", wordDict = ["apple","pen"]'
    output: "true"
    explanation: 'Return true because "applepenapple" can be segmented as "apple pen apple". Note that you are allowed to reuse a dictionary word.'
  - input: 's = "catsandog", wordDict = ["cats","dog","sand","and","cat"]'
    output: "false"

languages:
  python:
    starter_code: |
      class Solution:
          def wordBreak(self, s: str, wordDict: List[str]) -> bool:
              pass
    reference_solution: |
      class Solution:
          def wordBreak(self, s: str, wordDict: List[str]) -> bool:
              word_set = set(wordDict)
              n = len(s)
              # dp[i] = True if s[:i] can be segmented
              dp = [False] * (n + 1)
              dp[0] = True

              for i in range(1, n + 1):
                  for j in range(i):
                      if dp[j] and s[j:i] in word_set:
                          dp[i] = True
                          break

              return dp[n]
    function_signature:
      name: wordBreak
      params:
        - name: s
          type: str
        - name: wordDict
          type: "List[str]"
      return_type: bool

test_cases:
  - input: ["leetcode", ["leet", "code"]]
    expected: true
  - input: ["applepenapple", ["apple", "pen"]]
    expected: true
  - input: ["catsandog", ["cats", "dog", "sand", "and", "cat"]]
    expected: false
  - input: ["a", ["a"]]
    expected: true
  - input: ["a", ["b"]]
    expected: false
  - input: ["ab", ["a", "b"]]
    expected: true
  - input: ["abc", ["ab", "c"]]
    expected: true
  - input: ["abc", ["a", "bc"]]
    expected: true
  - input: ["abc", ["abc"]]
    expected: true
  - input: ["abc", ["ab", "bc"]]
    expected: false
  - input: ["cars", ["car", "ca", "rs"]]
    expected: true
  - input: ["aaaaaaa", ["aaaa", "aaa"]]
    expected: true
  - input: ["aaaaaaa", ["aaaa", "aa"]]
    expected: false
  - input: ["goalspecial", ["go", "goal", "goals", "special"]]
    expected: true
  - input: ["bb", ["a", "b", "bbb", "bbbb"]]
    expected: true
  - input: ["catskicatcats", ["cats", "cat", "dog", "ski"]]
    expected: true
  - input: ["catdog", ["cat", "dog"]]
    expected: true
  - input: ["catdog", ["cats", "dog"]]
    expected: false
  - input: ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab", ["a", "aa", "aaa", "aaaa", "aaaaa"]]
    expected: false
  - input: ["abcd", ["a", "abc", "b", "cd"]]
    expected: true
  - input: ["pineapplepenapple", ["apple", "pen", "applepen", "pine", "pineapple"]]
    expected: true
  - input: ["fohhemkkaecojceoaejkkoedkofhmohkcjmkggcmnami", ["kfomka", "hecuj", "anomf", "gcuj"]]
    expected: false
  - input: ["", ["a"]]
    expected: true
  - input: ["a", []]
    expected: false
  - input: ["abcdef", ["ab", "abc", "cd", "def", "abcd"]]
    expected: true
